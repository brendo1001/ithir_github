# Purpose        : Fit a mass-preserving spline to a single soil profile
# Maintainer     : Brendan Malone (brendan.malone@csiro.au)
# Contributions  : 
# Status         : working
# Note           : Uses precomputed spline matrices for efficient per-profile fitting
# Last Modified  : 2025-05-20

# Description:
# This function fits a mass-preserving spline to a single vector of soil values 
# (e.g., from one raster cell). It uses precomputed matrix components to avoid
# repeated matrix inversion. The fitted spline is interpolated at regular depth intervals,
# then averaged over specified output depth ranges.

# Inputs:
#   vals        : numeric vector of profile values (length must match length(dIn) - 1)
#   spline_info : list of spline matrices generated by precompute_spline_structures()
#   dOut        : numeric vector defining output depth intervals (e.g., c(0,30,60))
#   vlow        : minimum bound for spline predictions (e.g., 0)
#   vhigh       : maximum bound for spline predictions (e.g., 100)
#   depth_res   : interpolation resolution in cm (e.g., 1 = every cm; default = 1)

# Output:
#   A numeric vector of average values for each output depth interval.

fit_mpspline_optimized <- function(vals, spline_info, dOut, vlow, vhigh, depth_res = 1) {
  
  # Return NA vector if input is all NA or does not match expected length
  if (all(is.na(vals)) || length(vals) != length(spline_info$u)) {
    return(rep(NA, length(dOut) - 1))
  }
  
  # Unpack spline structures from precomputed info
  u <- spline_info$u
  v <- spline_info$v
  delta <- spline_info$delta
  z <- spline_info$z
  rinv <- spline_info$rinv
  q <- spline_info$q
  y <- vals
  n <- length(y)
  
  # Solve spline system to estimate average values for each layer
  sbar <- solve(z, y)
  
  # Calculate second derivative component and curvature adjustments
  b <- 6 * rinv %*% q %*% sbar
  b0 <- c(0, b)
  b1 <- c(b, 0)
  gamma <- (b1 - b0) / (2 * delta)
  alfa <- sbar - b0 * delta / 2 - gamma * delta^2 / 3
  
  # Interpolate spline across entire depth profile at specified resolution
  mxd <- max(v)
  xfit <- seq(1, mxd, by = depth_res)
  yfit <- rep(NA, length(xfit))
  
  for (k in seq_along(xfit)) {
    xd <- xfit[k]
    
    # Extrapolate above top layer
    if (xd < u[1]) {
      yfit[k] <- alfa[1]
    } else {
      for (i in 1:n) {
        tf2 <- if (i < n) xd > v[i] & xd < u[i + 1] else FALSE
        
        # Fit within layer
        if (xd >= u[i] & xd <= v[i]) {
          yfit[k] <- alfa[i] + b0[i] * (xd - u[i]) + gamma[i] * (xd - u[i])^2
          break
          
          # Handle transition between layers
        } else if (tf2) {
          phi <- alfa[i + 1] - b1[i] * (u[i + 1] - v[i])
          yfit[k] <- phi + b1[i] * (xd - v[i])
          break
        }
      }
    }
  }
  
  # Clip predictions to specified bounds
  yfit[yfit > vhigh] <- vhigh
  yfit[yfit < vlow]  <- vlow
  
  # Warn if output depth range exceeds available interpolation range
  if (max(dOut) > max(xfit)) {
    warning("Some dOut intervals extend beyond the interpolation range. Averaging only over available depths.")
  }
  
  # Average spline predictions over requested output depth intervals
  dl <- dOut + 1  # shift to 1-based indexing
  output <- sapply(1:(length(dl) - 1), function(j) {
    start_idx <- min(dl[j], length(yfit))
    end_idx <- min(dl[j + 1] - 1, length(yfit))
    if (start_idx > end_idx) {
      NA
    } else {
      mean(yfit[start_idx:end_idx], na.rm = TRUE)
    }
  })
  
  return(output)
}
